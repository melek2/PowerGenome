<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>settings_documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="settings_documentation_files/libs/clipboard/clipboard.min.js"></script>
<script src="settings_documentation_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="settings_documentation_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="settings_documentation_files/libs/quarto-html/popper.min.js"></script>
<script src="settings_documentation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="settings_documentation_files/libs/quarto-html/anchor.min.js"></script>
<link href="settings_documentation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="settings_documentation_files/libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="settings_documentation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="settings_documentation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="settings_documentation_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="powergenome-settings-file-documentation" class="level1">
<h1>PowerGenome settings file documentation</h1>
<p>This file provides documentation of each parameter in the current version of PowerGenome. It attempts to provide a comprehensive description of the data type and purpose of every parameter.</p>
<section id="model-regions-and-planning-periods" class="level2">
<h2 class="anchored" data-anchor-id="model-regions-and-planning-periods">Model regions and planning periods</h2>
<p>These parameters are used to define the regions that will be included in a model - including if/how IPM regions should be aggregated into model regions - and the planning period years.</p>
<section id="model_regions" class="level3">
<h3 class="anchored" data-anchor-id="model_regions">model_regions</h3>
<p>type: list(str)</p>
<p>description: The names of model regions that will be used in output files. These can either be single IPM regions or the name assigned to a group of (one or more) IPM regions in <code>region_aggregations</code>.</p>
</section>
<section id="region_aggregations" class="level3">
<h3 class="anchored" data-anchor-id="region_aggregations">region_aggregations</h3>
<p>type: dict(list(str))</p>
<p>description: A dictionary with list values, used to aggregate IPM regions into groups. The keys, which are names of the aggregated regions, should be used in <code>model_regions</code>. These region names should also be used in the following parameters:</p>
<ul>
<li><code>regional_no_grouping</code></li>
<li><code>alt_num_clusters</code></li>
<li><code>regional_tag_values</code></li>
<li><code>new_gen_not_available</code></li>
<li><code>new_wind_solar_regional_bins</code> (depreciated)</li>
<li><code>cost_multiplier_region_map</code></li>
<li><code>load_region_map</code></li>
<li><code>future_load_region_map</code></li>
<li><code>alt_growth_rate</code></li>
<li><code>aeo_fuel_region_map</code></li>
</ul>
</section>
<section id="regional_capacity_reserves" class="level3">
<h3 class="anchored" data-anchor-id="regional_capacity_reserves">regional_capacity_reserves</h3>
<p>type: Dict[str, Dict[str, float]]</p>
<p>description: A nested dictionary of capacity reserve constraints for model regions. The top-level keys are of form <code>CapRes_&lt;num&gt;</code>. The next level of keys are model regions, with values equal to the capacity reserve requirements.</p>
</section>
<section id="cap_res_network_derate_default" class="level3">
<h3 class="anchored" data-anchor-id="cap_res_network_derate_default">cap_res_network_derate_default</h3>
<p>type: float</p>
<p>description: The derating of transmission imports used to meet capacity reserve requirements.</p>
<!-- Combine model_year and model_first_planning_year into a list of tuples -->
</section>
<section id="model_year" class="level3">
<h3 class="anchored" data-anchor-id="model_year">model_year</h3>
<p>type: List[int]</p>
<p>description: Integer values. The final year in each planning period. Can be considered the planning year for capacity expansion.</p>
</section>
<section id="model_first_planning_year" class="level3">
<h3 class="anchored" data-anchor-id="model_first_planning_year">model_first_planning_year</h3>
<p>type: List[int]</p>
<p>description: Integer values. The first year in each planning period. These are combined with the values from <code>model_year</code> to define the range of years for each planning period. Cost values (capex, fuel cost, etc) are the average of values from all years within a planning period.</p>
</section>
</section>
<section id="time-reduction" class="level2">
<h2 class="anchored" data-anchor-id="time-reduction">Time reduction</h2>
<p>PowerGenome can reduce hourly demand/generation data to a series of time periods/slices. These parameters control how many periods will be used, how many days each period should be, if the day with peak demand should be included, and if/how much demand should be weighted relative to generation profiles when selecting representative time periods.</p>
<section id="reduce_time_domain" class="level3">
<h3 class="anchored" data-anchor-id="reduce_time_domain">reduce_time_domain</h3>
<p>type: bool</p>
<p>description: If the load and generation profiles should be reduced from 8760 hourly values to a representative subset of hours.</p>
</section>
<section id="time_domain_periods" class="level3">
<h3 class="anchored" data-anchor-id="time_domain_periods">time_domain_periods</h3>
<p>type: int</p>
<p>description: The number of periods (or clusters) of days. As an example, a system with 10 representative weeks would have 10 periods.</p>
</section>
<section id="time_domain_days_per_period" class="level3">
<h3 class="anchored" data-anchor-id="time_domain_days_per_period">time_domain_days_per_period</h3>
<p>type: int</p>
<p>description: The number of days (24 consecutive hours) to include in each period. If a model uses operational constraints like start-up or shutdown times then multiple days might be appropriate.</p>
</section>
<section id="include_peak_day" class="level3">
<h3 class="anchored" data-anchor-id="include_peak_day">include_peak_day</h3>
<p>type: bool</p>
<p>description: If the system-wide peak demand day should be included in one of periods.</p>
</section>
<section id="demand_weight_factor" class="level3">
<h3 class="anchored" data-anchor-id="demand_weight_factor">demand_weight_factor</h3>
<p>type: int</p>
<p>description: Demand and variable generation profiles are scaled from 0-1 before calculating clusters. Demand profiles are then multiplied by this parameter. Values greater than 1 will weight demand more heavily than variable generation profiles.</p>
</section>
</section>
<section id="multi-scenarioperiod-and-user-input-parameters" class="level2">
<h2 class="anchored" data-anchor-id="multi-scenarioperiod-and-user-input-parameters">Multi-scenario/period and user-input parameters</h2>
<p>Users need to supply additional information about scenarios and some data that are not yet included in PowerGenome. These parameters point to where those files are located (relative to the settings file).</p>
<section id="input_folder" class="level3">
<h3 class="anchored" data-anchor-id="input_folder">input_folder</h3>
<p>type: str</p>
<p>description: Name of a subfolder - directly below the settings file - with user-supplied scenario information and extra input data.</p>
</section>
<section id="case_id_description_fn" class="level3">
<h3 class="anchored" data-anchor-id="case_id_description_fn">case_id_description_fn</h3>
<p>type: str</p>
<p>description: Pointer to a csv file with columns <code>case_id</code> and <code>case_description</code>. <code>case_id</code> is a shorthand id for longer case description names.</p>
</section>
<section id="scenario_definitions_fn" class="level3">
<h3 class="anchored" data-anchor-id="scenario_definitions_fn">scenario_definitions_fn</h3>
<p>type: str</p>
<p>description: Pointer to a csv file that starts with mandatory columns <code>case_id</code>, which should use <code>case_id</code> from the file <code>case_id_description.csv</code> as a foreign key, and <code>year</code>, which should match the <code>model_year</code> values from the settings file. Every <code>case_id</code> should have a row for each value of <code>year</code> - make sure that the number of rows is equal to the number of unique case ids multiplied by the number of model years. All other columns are user-defined names that refer to the types of parameters in the settings file that will being changed across cases. The values in each column are also user-defined strings describing the scenario (e.g.&nbsp;“high”, “mid”, “low”).</p>
<p>The column names and values in each column are used in the settings parameter <code>settings_management</code> to define how the default settings values should be changed across each case.</p>
</section>
<section id="distributed_gen_profiles_fn" class="level3">
<h3 class="anchored" data-anchor-id="distributed_gen_profiles_fn">distributed_gen_profiles_fn</h3>
<p>type: str</p>
<p>description: Pointer to a csv file with normalized hourly generation profiles for distributed generation in all model regions listed in the settings file under <code>distributed_gen_method</code> and <code>distributed_gen_values</code>.</p>
</section>
<section id="demand_response_fn" class="level3">
<h3 class="anchored" data-anchor-id="demand_response_fn">demand_response_fn</h3>
<p>type: str</p>
<p>description: Pointer to a csv file with hourly (not normalized) profiles for demand response resources in each region/year/scenario. The top four rows are 1) the name of the DR resource (matching key values in the settings parameter <code>flexible_demand_resources</code>), 2) the model year, 3) the scenario name (scenarios are selected using the <code>demand_response</code> settings parameter), and 4) the model region from <code>model_regions</code>.</p>
</section>
<section id="emission_policies_fn" class="level3">
<h3 class="anchored" data-anchor-id="emission_policies_fn">emission_policies_fn</h3>
<p>type: str</p>
<p>description: Pointer to a csv file that describes the emission policies in each case. The first two columns are <code>case_id</code> and <code>year</code>. Next, the <code>region</code> column can either contain the name of a model region or the string “all” (when identical policies are applied to all regions). The column <code>copy_case_id</code> indicates if policies from another case should be used (slightly more clear and hopefully fewer errors than just using copy/paste across multiple rows). Other column names should match the columns used in output policy files (e.g.&nbsp;<code>RPS</code>, <code>CES</code>, etc) and contain numeric values or the string <code>None</code>.</p>
</section>
<section id="capacity_limit_spur_fn" class="level3">
<h3 class="anchored" data-anchor-id="capacity_limit_spur_fn">capacity_limit_spur_fn</h3>
<p>type: str</p>
<p>description: Provides the maximum capacity and spur-line construction distance for new (non-renewable) resources. Starts with the required columns <code>region</code> and <code>technology</code>. <code>cluster</code> can be omitted, but is required when more than one resource of the same name is used within a region.</p>
<p>The data columns in this file are <code>spur_miles</code> and <code>max_capacity</code>.</p>
</section>
<section id="demand_segments_fn" class="level3">
<h3 class="anchored" data-anchor-id="demand_segments_fn">demand_segments_fn</h3>
<p>type: str</p>
<p>description: Describes segments of demand, and the cost for not meeting demand within that segment.</p>
<p><strong>expand</strong></p>
</section>
<section id="misc_gen_inputs_fn" class="level3">
<h3 class="anchored" data-anchor-id="misc_gen_inputs_fn">misc_gen_inputs_fn</h3>
<p>type: str</p>
<p>description: This file is where users can add extra or miscellaneous inputs for generators. These inputs can include operating constraints like startup/shutdown times, power-to-energy ratios, and any other inputs that are not covered by PowerGenome.</p>
</section>
<section id="genx_settings_fn" class="level3">
<h3 class="anchored" data-anchor-id="genx_settings_fn">genx_settings_fn</h3>
<p>type: str</p>
<p>description: This is a YAML file used to record input parameters for GenX model runs. A version is copied into each of the final case folders. *This parameter is depreciated in preference of <code>genx_settings_folder</code> now that GenX expects a folder of settings files.</p>
</section>
<section id="genx_settings_folder" class="level3">
<h3 class="anchored" data-anchor-id="genx_settings_folder">genx_settings_folder</h3>
<p>type: str</p>
<p>description: This is a folder of YAML files used to record input parameters for GenX model runs. A version is copied into each of the final case folders.</p>
</section>
<section id="regional_load_fn" class="level3">
<h3 class="anchored" data-anchor-id="regional_load_fn">regional_load_fn</h3>
<p>type: str</p>
<p>description: An optional input file with hourly demand for each region. This file is only required if you don’t want to use the data included with PowerGenome.</p>
</section>
<section id="regional_load_includes_demand_response" class="level3">
<h3 class="anchored" data-anchor-id="regional_load_includes_demand_response">regional_load_includes_demand_response</h3>
<p>type: bool</p>
<p>description: Optional input, only required if using <code>regional_load_fn</code>. Do the user-supplied demand values already include flexible loads?</p>
</section>
<section id="distributed_gen_method" class="level3">
<h3 class="anchored" data-anchor-id="distributed_gen_method">distributed_gen_method</h3>
<p>type: dict</p>
<p>description: This is a dictionary with keys that can be any value from <code>model_regions</code>. Values define the method by which distributed generation profiles are calculated in each region. Available values are <code>capacity</code> and <code>fraction_load</code>. This method is used with <code>distributed_gen_values</code> and <code>distributed_gen_profiles_fn</code>.</p>
</section>
<section id="distributed_gen_values" class="level3">
<h3 class="anchored" data-anchor-id="distributed_gen_values">distributed_gen_values</h3>
<p>type: dict</p>
<p>description: This dictionary has top-level keys of model years from <code>model_year</code>, then regions from <code>model_region</code>, then a numeric value representing either <code>capacity</code> (MW) or <code>fraction_load</code> (0-1).</p>
</section>
<section id="avg_distribution_loss" class="level3">
<h3 class="anchored" data-anchor-id="avg_distribution_loss">avg_distribution_loss</h3>
<p>type: float</p>
<p>description: Distribution level line-loss is used when subtracting distributed generation from total load. Total load is load at the transmission network, so it includes distribution line loss.</p>
</section>
<section id="flexible_demand_resources" class="level3">
<h3 class="anchored" data-anchor-id="flexible_demand_resources">flexible_demand_resources</h3>
<p>type: dict</p>
<p>description: This nested dictionary has top-level keys of model years from <code>model_year</code>. The second level is names of demand response resources. Below the name are they keys:</p>
<ul>
<li><code>fraction_shiftable</code> (float)</li>
<li><code>parameter_values</code> (dict) with key: value pairs for specific columns in the GenX file <code>Generators_data.csv</code>.</li>
</ul>
</section>
<section id="demand_response" class="level3">
<h3 class="anchored" data-anchor-id="demand_response">demand_response</h3>
<p>type: str</p>
<p>description: The scenario name associated with columns in the <code>demand_response_fn</code> parameter. This value determines which scenario in the <code>demand_response_fn</code> file is used to modify demand curves and create flexible resources in the generators data.</p>
</section>
<section id="transmission_investment_cost" class="level3">
<h3 class="anchored" data-anchor-id="transmission_investment_cost">transmission_investment_cost</h3>
<p>type: dict</p>
<section id="transmission_investment_cost.use_total" class="level4">
<h4 class="anchored" data-anchor-id="transmission_investment_cost.use_total">transmission_investment_cost.use_total</h4>
<p>type: bool</p>
<p>description: If true, use precalculated interconnection_annuity from resource clusters. If false, calculate interconnection costs using the distances instead and capex provided in <code>transmission_investment_cost.spur</code>, <code>transmission_investment_cost.offshore_spur</code>, and <code>transmission_investment_cost.tx</code>.</p>
</section>
<section id="transmission_investment_cost.spur-offshore_spur-tx" class="level4">
<h4 class="anchored" data-anchor-id="transmission_investment_cost.spur-offshore_spur-tx">transmission_investment_cost.[spur, offshore_spur, tx]</h4>
<p>type: dict</p>
<p>description: These three dictionaries have keys <code>capex_mw_mile</code>, <code>wacc</code>, and <code>investment_years</code>. Capex values are provided for each model region, and used in conjuction with the weighted average cost of capital (<code>wacc</code>) and investment years to calculate annuities for transmission expansion/reinforcement. All three types can be used when calculating interconnection costs for new power plants. <code>tx</code> is used to calculate the cost of inter-regional transmission expansion.</p>
</section>
</section>
<section id="tx_expansion_per_period" class="level3">
<h3 class="anchored" data-anchor-id="tx_expansion_per_period">tx_expansion_per_period</h3>
<p>type: float, int</p>
<p>description: How much inter-regional transmission can be expanded/increased within a model period. A value of 1.0 allows transmission to double; 0.5 allows for a 50% increase.</p>
</section>
<section id="tx_line_loss_100_miles" class="level3">
<h3 class="anchored" data-anchor-id="tx_line_loss_100_miles">tx_line_loss_100_miles</h3>
<p>type: float, int</p>
<p>description: The fraction of electricity lost during each 100 miles of transmission between regions due to line loss. The default value of 0.01 represents a 1% loss per 100 miles.</p>
</section>
<section id="partial_ces" class="level3">
<h3 class="anchored" data-anchor-id="partial_ces">partial_ces</h3>
<p>type: bool</p>
<p>description: If true, resources are assigned a clean energy standard (CES) credit equal to the difference between their emission rate (in tons/MWh) and a coal plant (assumed to be 1 ton/MWh). Coal plants are not eligible for this credit even if they have emission rates below 1 ton/MWh. Note that units are imperial, not metric tonnes.</p>
</section>
<section id="data_years" class="level3">
<h3 class="anchored" data-anchor-id="data_years">data_years</h3>
<p>type: list(int)</p>
<p>description: The years of EIA 923 and 860 data to use when calculating heat rates of generators.</p>
</section>
<section id="target_usd_year" class="level3">
<h3 class="anchored" data-anchor-id="target_usd_year">target_usd_year</h3>
<p>type: int</p>
<p>description: The dollar year that all costs will be converted to.</p>
</section>
<section id="capacity_col" class="level3">
<h3 class="anchored" data-anchor-id="capacity_col">capacity_col</h3>
<p>type: str</p>
<p>description: The capacity of a generator is given in terms of <code>capacity_mw</code>, <code>winter_capacity_mw</code>, or <code>summer_capacity_mw</code>, representing the reported nameplate, winter, and summer capacity. Use one of these three values to determine the total capacity available in each resource cluster. Summer is usually the lowest value, and nameplate the highest.</p>
</section>
</section>
<section id="classify-some-hydro-units-as-small" class="level2">
<h2 class="anchored" data-anchor-id="classify-some-hydro-units-as-small">Classify some hydro units as “small”</h2>
<p>Some regions treat small hydroelectric generators differently for RPS eligibility, or you may want to model them as run-of-river. These parameters are used to rename some hydro resources as “Small Hydroelectic”.</p>
<section id="small_hydro" class="level3">
<h3 class="anchored" data-anchor-id="small_hydro">small_hydro</h3>
<p>type: bool</p>
<p>description: If PG should separate small hydroelectric dams into their own resource type. Some states treat small hydro different from large hydro for RPS qualification.</p>
</section>
<section id="small_hydro_mw" class="level3">
<h3 class="anchored" data-anchor-id="small_hydro_mw">small_hydro_mw</h3>
<p>type: int</p>
<p>description: The generator size (MW) below which hydroelectric units are considered “small”.</p>
</section>
<section id="small_hydro_regions" class="level3">
<h3 class="anchored" data-anchor-id="small_hydro_regions">small_hydro_regions</h3>
<p>type: list(str)</p>
<p>description: Regions from <code>model_regions</code> that will have hydroelectric generators split into small and conventional. Regions not listed here will not have small hydro split out.</p>
</section>
</section>
<section id="clustering-existing-generators" class="level2">
<h2 class="anchored" data-anchor-id="clustering-existing-generators">Clustering existing generators</h2>
<p>PowerGenome is set up to cluster existing generating units within regions. These parameters determine how units are clustered within each region.</p>
<p>In addition to clustering units within a technology, users can group several technologies together. This is most useful to combine several technologies with only a few units and little capacity.</p>
<section id="cluster_method" class="level3">
<h3 class="anchored" data-anchor-id="cluster_method">cluster_method</h3>
<p>type: str</p>
<p>description: Not implemented yet, leave as <code>kmeans</code></p>
</section>
<section id="num_clusters" class="level3">
<h3 class="anchored" data-anchor-id="num_clusters">num_clusters</h3>
<p>type: Dict[str, int]</p>
<p>description: The default number of clusters that resources will be split into in every region. More than one cluster might be appropriate if there are a large number of resources with varied ages/sizes/heat rates. Use <code>alt_num_clusters</code> to specify a different number of resource clusters in specific regions.</p>
</section>
<section id="alt_num_clusters" class="level3">
<h3 class="anchored" data-anchor-id="alt_num_clusters">alt_num_clusters</h3>
<p>type: Dict[str, Dict[str, int]]</p>
<p>description: A nested dictionary with keys from <code>model_regions</code>, and values that are a key: value pair of the resource name (from EIA) and the number of clusters to create within that region. This parameter lets you set a different number of clusters for a resource within a specific region. You can specify a value of 0 to drop a resource from within a region, which is useful when only a few generators exist and they have extremely high heat rates according to EIA data.</p>
</section>
<section id="alt_cluster_method" class="level3">
<h3 class="anchored" data-anchor-id="alt_cluster_method">alt_cluster_method</h3>
<p>type: str</p>
<p>description: Not currently in use. Designed to specify different algorithms for clustering existing generators.</p>
</section>
<section id="group_technologies" class="level3">
<h3 class="anchored" data-anchor-id="group_technologies">group_technologies</h3>
<p>type: bool</p>
<p>description: If <code>True</code>, group different technologies together as specified in <code>tech_groups</code>. This can be used to combine multiple small capacity technologies that serve a similar purpose or have similar fuel inputs.</p>
</section>
<section id="tech_groups" class="level3">
<h3 class="anchored" data-anchor-id="tech_groups">tech_groups</h3>
<p>type: dict</p>
<p>description: Key values are the name for a grouping of technologies, values are a list of the EIA technology names to include in the group. This renames all of the listed technologies to the group name.</p>
</section>
<section id="regional_no_grouping" class="level3">
<h3 class="anchored" data-anchor-id="regional_no_grouping">regional_no_grouping</h3>
<p>type: dict</p>
<p>description: Keys are model regions, values are a list with names of EIA technologies that should not be grouped into the <code>tech_groups</code> categories within that region. Exclude or set as None (~) if not used.</p>
<p>example:</p>
<pre><code>regional_no_grouping:
  CA_S:
    - Landfill Gas
    - Municipal Solid Waste</code></pre>
</section>
<section id="capacity_factor_techs" class="level3">
<h3 class="anchored" data-anchor-id="capacity_factor_techs">capacity_factor_techs</h3>
<p>type: list</p>
<p>description: (Not used anymore, fix in code.) Existing technologies that should have their capacity discounted by their average capacity factor (calculated using generation data from <code>capacity_factor_default_year_filter</code>).</p>
</section>
<section id="capacity_factor_default_year_filter" class="level3">
<h3 class="anchored" data-anchor-id="capacity_factor_default_year_filter">capacity_factor_default_year_filter</h3>
<p>type: list</p>
<p>description: The years of data to use when calculating capacity factors for each technology cluster.</p>
</section>
<section id="alt_year_filters" class="level3">
<h3 class="anchored" data-anchor-id="alt_year_filters">alt_year_filters</h3>
<p>type: dict</p>
<p>description: Keys are EIA technology names, values are a list of years to use when calculating the capacity factor of that technology.</p>
</section>
<section id="derate_capacity" class="level3">
<h3 class="anchored" data-anchor-id="derate_capacity">derate_capacity</h3>
<p>type: bool</p>
<p>description: If calculated capacity factors should be used to derate the total capacity of a technology.</p>
</section>
<section id="energy_storage_duration" class="level3">
<h3 class="anchored" data-anchor-id="energy_storage_duration">energy_storage_duration</h3>
<p>type: Dict[str, float]</p>
<p>description: Energy storge duration for existing technologies (e.g.&nbsp;pumped hydro). Keys are the technology name, values are the length of storage duration in hours.</p>
</section>
<section id="retirement_ages" class="level3">
<h3 class="anchored" data-anchor-id="retirement_ages">retirement_ages</h3>
<p>type: dict</p>
<p>description: Keys are EIA technology names, values are the maximum age of a generator that will be included in PowerGenome outputs. Generator age is calculated as the difference between <code>model_year</code> and the “operating date” year specified in EIA 860. If you want a capacity expansion model to control all retirements for a technology, set the retirement age to some very high value like 500.</p>
<p><strong>IMPORTANT</strong> If you are running a myopic model with multiple planning periods, age-based retirements between planning periods can change the units assigned to each cluster. In this situation the heat rates and O&amp;M of a cluster will change because of the units it contains. Economic retirements of capacity from a cluster may not accurately represent the units that should be retired. To avoid this, set all retirement ages to a large value (e.g.&nbsp;500).</p>
</section>
</section>
<section id="model-tags" class="level2">
<h2 class="anchored" data-anchor-id="model-tags">Model tags</h2>
<section id="model_tag_names" class="level3">
<h3 class="anchored" data-anchor-id="model_tag_names">model_tag_names</h3>
<p>type: list</p>
<p>description: This parameter was designed specifically for GenX outputs. The file <code>Generators_data.csv</code> has several “model tag” columns that identify attributes of resources (e.g.&nbsp;if they can be committed, if they are hydro, if they are thermal, etc). The function <code>generators.add_genx_model_tags</code> (Note: need to rename or move to the <code>GenX</code> module) adds columns to a dataframe with the default value from settings parameter <code>default_model_tag</code>. Values in each row are then set by technology/resource name according to the settings parameter <code>model_tag_values</code>.</p>
</section>
<section id="default_model_tag" class="level3">
<h3 class="anchored" data-anchor-id="default_model_tag">default_model_tag</h3>
<p>type: int, float, str</p>
<p>description: This is the default value that each of the <code>model_tag_names</code> columns starts with.</p>
</section>
<section id="model_tag_values" class="level3">
<h3 class="anchored" data-anchor-id="model_tag_values">model_tag_values</h3>
<p>type: Dict[str, Dict[str, Union[int, float, str]]]</p>
<p>description: This nested dictionary should have top-level keys equal to the <code>model_tag_names</code> values. The second level keys will be string matched against EIA, ATB, or user-added technologies/resources. The values are “tags” or other identification infomation populated in the column for each matched resource.</p>
<p>Case insensitive string matching is used to identify technologies, so is not necessary to use full resource names. This is helpful when switching between ATB cost cases, because the resource name will include the cost case. Be careful though, because some resources may be matched against two different tag values.</p>
</section>
<section id="regional_tag_values" class="level3">
<h3 class="anchored" data-anchor-id="regional_tag_values">regional_tag_values</h3>
<p>type: Dict[str, Dict[str, Dict[str, Union[int, float, str]]]]</p>
<p>description: This parameter lets you set different tag values in specific regions. Potential use cases may include changing RPS eligibility or disallowing retirement (or new build) of a technology for a single region.</p>
</section>
<section id="mincapreq" class="level3">
<h3 class="anchored" data-anchor-id="mincapreq">MinCapReq</h3>
<p>type: Dict[str, Dict[str, Union[int, float, str]]]</p>
<p>description: This parameter specifies minimum capacity requirements. The top-level key (of format <code>MinCapTag_&lt;*&gt;</code>) is a model tag linking individual resources to a requirement. The next level of the nested dictionary has keys <code>description</code> and <code>min_mw</code>, specifying a short description of the capacity requirement and how many MWs are needed to satisfy it.</p>
</section>
</section>
<section id="new-generating-resources-from-nrel-atb" class="level2">
<h2 class="anchored" data-anchor-id="new-generating-resources-from-nrel-atb">New generating resources from NREL ATB</h2>
<p>ATB resources are identified using the <em>technology</em>, <em>tech detail</em>, and <em>cost case</em> with a string format of <code>&lt;technology&gt;_&lt;tech detail&gt;_&lt;cost case&gt;</code>.</p>
<section id="atb_data_year" class="level3">
<h3 class="anchored" data-anchor-id="atb_data_year">atb_data_year</h3>
<p>type: int</p>
<p>description: The year of ATB data to use (e.g.&nbsp;2020, 2021, etc.). Note that the <code>&lt;tech_detail&gt;</code> and <code>&lt;cost_case&gt;</code> names can vary between ATB years.</p>
</section>
<section id="atb_financial_case" class="level3">
<h3 class="anchored" data-anchor-id="atb_financial_case">atb_financial_case</h3>
<p>type: str</p>
<p>description: NREL’s ATB provides financial costs for both “Market” and “R&amp;D” scenarios. Select one of them to filter the ATB data.</p>
</section>
<section id="atb_cap_recovery_years" class="level3">
<h3 class="anchored" data-anchor-id="atb_cap_recovery_years">atb_cap_recovery_years</h3>
<p>type: int</p>
<p>description: The default number of years for capital recovery of new-build generators, used when calculating investment costs.</p>
</section>
<section id="alt_atb_cap_recovery_years" class="level3">
<h3 class="anchored" data-anchor-id="alt_atb_cap_recovery_years">alt_atb_cap_recovery_years</h3>
<p>type: Dict[str, int]</p>
<p>description: Alternate capital recovery timeframes for specific ATB technologies. The tech names are string matched against ATB string names (identified above).</p>
</section>
<section id="atb_existing_year" class="level3">
<h3 class="anchored" data-anchor-id="atb_existing_year">atb_existing_year</h3>
<p>type: int</p>
<p>description: In some cases (e.g.&nbsp;conbustion turbine variable O&amp;M), ATB data are used to populate costs for existing resources. This parameter sets the year of ATB data to use in these cases.</p>
</section>
<section id="atb_modifiers" class="level3">
<h3 class="anchored" data-anchor-id="atb_modifiers">atb_modifiers</h3>
<p>type: Dict[str, Dict[str, Union[str, Union[list, float]]]</p>
<p>description: This parameter modifies parameters for ATB technologies in-place (keeping the same name). Top-level keys are user names for each resource and are not used by PowerGenome. Below the top level, a dictionary with the ATB <code>technology</code> and <code>tech_detail</code> will also include keys of column names that should be modified. The values for each of these keys is either 1) a list, where the first value is a string operator name (<code>add</code>, <code>mul</code>, <code>truediv</code>, or <code>sub</code>) and the second value is the numeric value, or 2) a numeric value (<code>int</code> or <code>float</code>) that will directly replace the ATB value.</p>
<p>Valid column names are</p>
<ul>
<li><code>Var_OM_Cost_per_MWh</code></li>
<li><code>Fixed_OM_Cost_per_MWyr</code></li>
<li><code>Fixed_OM_Cost_per_MWhyr</code></li>
<li><code>Heat_Rate_MMBTU_per_MWh</code></li>
<li><code>capex_mw</code></li>
<li><code>capex_mwh</code></li>
<li><code>wacc_real</code></li>
</ul>
</section>
<section id="modified_atb_new_gen" class="level3">
<h3 class="anchored" data-anchor-id="modified_atb_new_gen">modified_atb_new_gen</h3>
<p>type: Dict[str, Dict[str, Union[str, list]]]</p>
<p>description: Similar to <code>atb_modifiers</code>, but this parameter creates a new and modified copy of a technology in ATB. In addition to the keys listed in <code>atb_modifiers</code>, this should have <code>new_technology</code>, <code>new_tech_detail</code>, <code>new_cost_case</code>, and <code>size_mw</code>.</p>
</section>
<section id="atb_battery_wacc" class="level3">
<h3 class="anchored" data-anchor-id="atb_battery_wacc">atb_battery_wacc</h3>
<p>type: Union[str, float]</p>
<p>description: ATB doesn’t have a weighted average cost of capital (WACC) for battery storage. Either include a numeric value or <code>UtilityPV</code> to use the same WACC as Utility PV.</p>
</section>
<section id="eia_atb_tech_map" class="level3">
<h3 class="anchored" data-anchor-id="eia_atb_tech_map">eia_atb_tech_map</h3>
<p>type: Dict[str, Union[str, List[str]]]</p>
<p>description: This is a mapping of EIA technology names to ATB technology strings (without the cost case). Key values can be a single ATB technology or a list of technologies. It is used to map start-up costs, so be sure to include all custom thermal technologies as part of the dictionary values.</p>
</section>
<section id="atb_new_gen" class="level3">
<h3 class="anchored" data-anchor-id="atb_new_gen">atb_new_gen</h3>
<p>type: List[list]</p>
<p>description: This controls the types of ATB new generation that are included in the generators dataframe. Each resource is specified as a list:</p>
<ul>
<li>technology</li>
<li>tech detail</li>
<li>cost case</li>
<li>size of each unit</li>
</ul>
</section>
<section id="new_gen_not_available" class="level3">
<h3 class="anchored" data-anchor-id="new_gen_not_available">new_gen_not_available</h3>
<p>type: Dict[str, list]</p>
<p>description: Not all resources are available in all regions. The top-level keys here are model regions, and values are a list of resources (string matched) that should not be included for that region.</p>
</section>
<section id="renewable_clusters" class="level3">
<h3 class="anchored" data-anchor-id="renewable_clusters">renewable_clusters</h3>
<p>type: List[dict]</p>
<p>description: Specify the type of new-build resource (<code>utilitypv</code>, <code>landbasedwind</code>, or <code>offshorewind</code>), maximum capacity (MW), number of clusters, and maximum LCOE (optional) in a model region. The required keys in each dictionary are:</p>
<ul>
<li><code>region</code></li>
<li><code>technology</code></li>
<li><code>max_clusters</code></li>
<li><code>min_capacity</code></li>
</ul>
<p>For <code>utilitypv</code>, users should also include a key <code>cap_multiplier</code>. The original capacities were calculated using a resource density of 45 MW/km^2. The default parameter of 0.2 reduces this by 80%.</p>
<p>The optional key <code>max_lcoe</code> can be used as a rough cost-cutoff. It uses a pre-calculated LCOE based on 2030 mid-range costs from ATB 2019.</p>
<p>Technologies that have additional characteristics need to have those parameters specified in the dictionary. An example of this is <code>offshorewind</code>, where the parameters <code>turbine_type</code> (<code>fixed</code> or <code>floating</code>) and <code>pref_site</code> (<code>0</code> or <code>1</code>) must be included. <code>pref_site</code> is a boolean variable indicating if the project site is included in a BOEM lease area or an NREL study of Pacific floating wind.</p>
</section>
<section id="cost_multiplier_fn" class="level3">
<h3 class="anchored" data-anchor-id="cost_multiplier_fn">cost_multiplier_fn</h3>
<p>type: str</p>
<p>description: The file name containing AEO regional multipliers for different technology types.</p>
</section>
<section id="cost_multiplier_region_map" class="level3">
<h3 class="anchored" data-anchor-id="cost_multiplier_region_map">cost_multiplier_region_map</h3>
<p>type: Dict[str, list]</p>
<p>description: ATB resource costs do not reflect cost differences across the country. This dictionary maps model regions to regional cost differences reported in EIA AEO 2020. IPM regions have been pre-populated in the example settings file, but all regions from <code>model_regions</code> must be included.</p>
</section>
<section id="cost_multiplier_technology_map" class="level3">
<h3 class="anchored" data-anchor-id="cost_multiplier_technology_map">cost_multiplier_technology_map</h3>
<p>type: Dict[str, list]</p>
<p>description: ATB technologies need to be matched against the names included in AEO’s regional cost multiplier table. All of the ATB technologies are already included in the example file, but any new or modified technologies should be added.</p>
</section>
</section>
<section id="load-growth" class="level2">
<h2 class="anchored" data-anchor-id="load-growth">Load growth</h2>
<section id="default_load_year" class="level3">
<h3 class="anchored" data-anchor-id="default_load_year">default_load_year</h3>
<p>type: int</p>
<p>description: The year that default load/demand curves are from.</p>
</section>
<section id="regular_load_growth_start_year" class="level3">
<h3 class="anchored" data-anchor-id="regular_load_growth_start_year">regular_load_growth_start_year</h3>
<p>type: int</p>
<p>description: Historical demand/load curves are inflated from <code>default_load_year</code> to this value using historical AEO data.</p>
</section>
<section id="historical_load_region_maps" class="level3">
<h3 class="anchored" data-anchor-id="historical_load_region_maps">historical_load_region_maps</h3>
<p>type: Dict[str, list]</p>
<p>description: This parameter matches IPM regions to AEO regions for inflating demand from the historical starting point to current values. Because AEO changed the electricity regions between AEO 2019 and AEO 2020, the keys in this dictionary are different from those in <code>future_load_region_map</code>.</p>
</section>
<section id="future_load_region_map" class="level3">
<h3 class="anchored" data-anchor-id="future_load_region_map">future_load_region_map</h3>
<p>type: Dict[str, list]</p>
<p>description: This parameter matches IPM regions to AEO regions for inflating demand from current values to a future planning year. Because AEO changed the electricity regions between AEO 2019 and AEO 2020, the keys in this dictionary are different from those in <code>future_load_region_map</code>.</p>
</section>
<section id="alt_growth_rate" class="level3">
<h3 class="anchored" data-anchor-id="alt_growth_rate">alt_growth_rate</h3>
<p>type: Dict[str, float]</p>
<p>description: This parameter lets you set future growth rates for individual IPM regions (<strong>not</strong> model regions).</p>
</section>
</section>
<section id="fuel-prices" class="level2">
<h2 class="anchored" data-anchor-id="fuel-prices">Fuel prices</h2>
<section id="aeo_fuel_region_map" class="level3">
<h3 class="anchored" data-anchor-id="aeo_fuel_region_map">aeo_fuel_region_map</h3>
<p>type: Dict[str, list]</p>
<p>description: Keys are EIA fuel region names (from <code>eia_series_region_names</code>), values are a list of model regions that correspond to each region. Some regional may not fit fully within the EIA regions - this is which region you want to use AEO fuel price data from.</p>
</section>
<section id="eia_series_region_names" class="level3">
<h3 class="anchored" data-anchor-id="eia_series_region_names">eia_series_region_names</h3>
<p>type: Dict[str, str]</p>
<p>description: A mapping of model names for each AEO fuel region to the string code used in EIA’s API.</p>
</section>
<section id="eia_series_fuel_names" class="level3">
<h3 class="anchored" data-anchor-id="eia_series_fuel_names">eia_series_fuel_names</h3>
<p>type: Dict[str, str]</p>
<p>description: A mapping of model names for each AEO fuel type to the string code used in EIA’s API.</p>
</section>
<section id="eia_aeo_year" class="level3">
<h3 class="anchored" data-anchor-id="eia_aeo_year">eia_aeo_year</h3>
<p>type: int</p>
<p>description: The year of EIA AEO data to use for fuel prices. Note that different years have different scenario names so those may need to be modified accordingly in <code>eia_series_scenario_names</code>.</p>
</section>
<section id="eia_series_scenario_names" class="level3">
<h3 class="anchored" data-anchor-id="eia_series_scenario_names">eia_series_scenario_names</h3>
<p>type: Dict[str, str]</p>
<p>description: A mapping of the model name for each AEO scenario to the string code used in EIA’s API. These may change based on the AEO year used, and not all scenarios are included in the example file. For a full list, look at the eia <a href="https://www.eia.gov/opendata/qb.php?category=3604304">open data page</a>.</p>
</section>
<section id="aeo_fuel_scenarios" class="level3">
<h3 class="anchored" data-anchor-id="aeo_fuel_scenarios">aeo_fuel_scenarios</h3>
<p>type: Dict[str, str]</p>
<p>description: The AEO scenario (names from <code>eia_series_scenario_names</code>) to use for each fuel type.</p>
</section>
<section id="aeo_fuel_usd_year" class="level3">
<h3 class="anchored" data-anchor-id="aeo_fuel_usd_year">aeo_fuel_usd_year</h3>
<p>type: int</p>
<p>description: The dollar year of AEO fuel price data.</p>
</section>
<section id="tech_fuel_map" class="level3">
<h3 class="anchored" data-anchor-id="tech_fuel_map">tech_fuel_map</h3>
<p>type: Dict[str, str]</p>
<p>description: A mapping of fuel types (from <code>aeo_fuel_scenarios</code> or <code>user_fuel_prices</code>) to EIA technology names. ATB technologies are mapped to the EIA names in <code>eia_atb_tech_map</code>. Both technologies are assigned a fuel type based on this parameter. Mappings can be done directly to non-EIA technologies but they must include the complete string match of a technology.</p>
</section>
<section id="user_fuel_prices" class="level3">
<h3 class="anchored" data-anchor-id="user_fuel_prices">user_fuel_prices</h3>
<p>type: Dict[str, Union[float, Dict[str, float]]]</p>
<p>description: This is where users can define their own fuel types that aren’t included in EIA AEO. The price for a fuel can be across all model regions (use a numeric value) or for each model region (use a dictionary mapping prices to regions).</p>
</section>
<section id="user_fuel_usd_year" class="level3">
<h3 class="anchored" data-anchor-id="user_fuel_usd_year">user_fuel_usd_year</h3>
<p>type: Dict[str, int]</p>
<p>description: The dollar year of price data for each user fuel. Only a single value is allowed, unlike the regional option in <code>user_fuel_prices</code>. If no dollar year is given for a user fuel the price will not be modified to match <code>target_usd_year</code>.</p>
</section>
<section id="ccs_fuel_map" class="level3">
<h3 class="anchored" data-anchor-id="ccs_fuel_map">ccs_fuel_map</h3>
<p>type: Dict[str, str]</p>
<p>description: A mapping ATB or user CCS technology names to CCS fuel names (key values on right have to be in the format <code>&lt;fuel&gt;_&lt;ccslevel&gt;</code>) where the fuel matches something from <code>aeo_fuel_scenarios</code> or <code>user_fuel_prices</code>.</p>
</section>
<section id="ccs_capture_rate" class="level3">
<h3 class="anchored" data-anchor-id="ccs_capture_rate">ccs_capture_rate</h3>
<p>type: Dict[str, float]</p>
<p>description: The name of each CCS fuel (from <code>ccs_fuel_map</code>) and the capture rate associated with that fuel. Emission rates for each fuel will be based on the base fuel name and be adjusted for the capture rate.</p>
</section>
<section id="ccs_disposal_cost" class="level3">
<h3 class="anchored" data-anchor-id="ccs_disposal_cost">ccs_disposal_cost</h3>
<p>type: Union[int, float]</p>
<p>description: Pipeline and other costs for CCS disposal operations that are added to the fuel price for CCS fuels. Units are USD/ton.</p>
</section>
<section id="carbon_tax" class="level3">
<h3 class="anchored" data-anchor-id="carbon_tax">carbon_tax</h3>
<p>type: Union[int, float]</p>
<p>description: This parameter adds a carbon tax cost to fuel costs.</p>
</section>
<section id="fuel_emission_factors" class="level3">
<h3 class="anchored" data-anchor-id="fuel_emission_factors">fuel_emission_factors</h3>
<p>type: Dict[str, float]</p>
<p>description: Emission factors provided in the example settings file are from EIA. Coal emission factors are average for the electric power sector.</p>
</section>
</section>
<section id="generator-startup-costs" class="level2">
<h2 class="anchored" data-anchor-id="generator-startup-costs">Generator startup costs</h2>
<section id="startup_vom_costs_mw" class="level3">
<h3 class="anchored" data-anchor-id="startup_vom_costs_mw">startup_vom_costs_mw</h3>
<p>type: Dict[str, float]</p>
<p>description: Variable O&amp;M startup costs for different power plant types. The values provided are from the NREL Western wind/solar integration study. Plant types should match the values in <code>existing_startup_costs_tech_map</code>, and <code>new_build_startup_costs</code>.</p>
</section>
<section id="startup_vom_costs_usd_year" class="level3">
<h3 class="anchored" data-anchor-id="startup_vom_costs_usd_year">startup_vom_costs_usd_year</h3>
<p>type: int</p>
<p>description: Dollar year of costs in <code>startup_vom_costs_mw</code> parameter.</p>
</section>
<section id="startup_costs_type" class="level3">
<h3 class="anchored" data-anchor-id="startup_costs_type">startup_costs_type</h3>
<p>type: str</p>
<p>description: Name of the paramter to use for startup costs. The default value in the example documenation is <code>startup_costs_per_cold_start_mw</code>, but users can change this parameter (and add other cost sources) if you want.</p>
</section>
<section id="startup_costs_per_cold_start_mw" class="level3">
<h3 class="anchored" data-anchor-id="startup_costs_per_cold_start_mw">startup_costs_per_cold_start_mw</h3>
<p>type: Dict[str, Union[int, float]]</p>
<p>description: Costs per cold start for different power plant types. The values provided in the example file are median cold start costs from NREL 2012.</p>
</section>
<section id="startup_costs_per_cold_start_usd_year" class="level3">
<h3 class="anchored" data-anchor-id="startup_costs_per_cold_start_usd_year">startup_costs_per_cold_start_usd_year</h3>
<p>type: int</p>
<p>description: Dollar year of costs in the dictionary specified by <code>startup_costs_type</code>.</p>
<p><strong>Need to rename the startup costs - maybe remove the “cold” descriptor and just keep as a single dictionary</strong></p>
</section>
<section id="existing_startup_costs_tech_map" class="level3">
<h3 class="anchored" data-anchor-id="existing_startup_costs_tech_map">existing_startup_costs_tech_map</h3>
<p>type: Dict[str, str]</p>
<p>description: Mapping of EIA technology names (existing generators) to plant types from <code>startup_vom_costs_mw</code> and <code>startup_costs_per_cold_start_mw</code>.</p>
</section>
<section id="new_build_startup_costs" class="level3">
<h3 class="anchored" data-anchor-id="new_build_startup_costs">new_build_startup_costs</h3>
<p>type: Dict[str, str]</p>
<p>description: Mapping of NREL ATB and user-defined technology names (new-build generators) to plant types from <code>startup_vom_costs_mw</code> and <code>startup_costs_per_cold_start_mw</code>.</p>
</section>
<section id="generator_columns" class="level3">
<h3 class="anchored" data-anchor-id="generator_columns">generator_columns</h3>
<p>type: List[str]</p>
<p>description: Column names from the new and existing generators dataframes to keep.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>